{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// axios\nimport axios from 'axios';\n\n// redux\nimport { useAppSelector, useAppDispatch } from '../hooks/reduxHook';\n\n// util\nimport { getNewAccessToken } from '../utils/getAccessToken';\n\n// types\n\n// redux\nimport { setAccessToken } from '../store/slice/loginSlice';\n\n// ? 변수 선언 말고 바로 넣는 게 보안상 더 좋으려나?\n\nconst REFRESH_URL = ''; // refresh URL을 새롭게 추가를 해야 한다.\n\nconst noneTokenClient = axios.create({\n  baseURL: process.env.REACT_APP_API_URL\n});\nconst tokenClient = axios.create({\n  baseURL: process.env.REACT_APP_API_URL\n});\n\n// *: 요청하는 상태에 따라서 무조건 토큰을 담아서 보낸다.\n_s(tokenClient.interceptors.request.use(_s(config => {\n  _s();\n  // * :요청 헤더가 있으면 기존의 것을 반환하고 없으면 아래 처럼 새롭게 지정해준다.\n  if (!config.headers) return config;\n  if (config.url === REFRESH_URL) {\n    config.headers.Authorization = `${useAppSelector(state => state.login.refreshToken)}`;\n  } else {\n    config.headers.Authorization = `${useAppSelector(state => state.login.accessToken)}`;\n  }\n  return config;\n}, \"6vLuQ0A+Lpw7xt9bKHHGaX+BB5o=\", false, function () {\n  return [useAppSelector, useAppSelector];\n})), \"6vLuQ0A+Lpw7xt9bKHHGaX+BB5o=\", false, function () {\n  return [useAppSelector, useAppSelector];\n});\n\n// *: token을 사용하는 response 설정\n_s2(tokenClient.interceptors.response.use(response => {\n  return response;\n}, _s2(async error => {\n  _s2();\n  const originalRequest = error.config;\n\n  // originalRequest._retry은 재시도 여부를 나타낸다(계속 요청하는 loop를 방지하기 위해)\n  if (error.response.status === 401 && originalRequest && !originalRequest._retry) {\n    originalRequest._retry = true;\n    try {\n      // refreshToken을 이용해 새로운 accessToken 발급\n      const {\n        accessToken\n      } = await getNewAccessToken();\n\n      // 새롭게 발급 받은 accessToken을 로컬 스토리지에 저장하기\n      const dispatch = useAppDispatch();\n      dispatch(setAccessToken(accessToken));\n\n      // *:새롭게 받은 accessToken을 다시 기존의 요청 헤더 권한에 부여\n      originalRequest.headers.authorization = `${accessToken}`;\n\n      // 실패했던 원래 요청에 대해 다시 요청을 보낸다.\n      return await axios(originalRequest);\n    } catch (error) {\n      // refreshToken으로 accessToken 발급을 실패한 경우\n      console.log('Error in getNewAccessToken: ', error);\n      // 로그아웃 처리 등의 작업을 한다. 발급 실패를 했으니 어떻게 해야 하나?\n      // 에러 페이지로 전환을 해야 할까?\n    }\n  }\n\n  return Promise.reject(error);\n}, \"BJQ1DUn/XFEl2NsQ3DWyHAXfnkY=\", false, function () {\n  return [useAppDispatch];\n})), \"BJQ1DUn/XFEl2NsQ3DWyHAXfnkY=\", false, function () {\n  return [useAppDispatch];\n});\n\n// *: token을 사용하지 않는 response 설정\nnoneTokenClient.interceptors.response.use(response => {\n  return response;\n}, error => {\n  const errorResponse = {\n    ...error.response.data\n  };\n  return Promise.reject(errorResponse);\n});\nexport const userAPI = {};\nexport const PortfolioAPI = {\n  getPortfolio: async portfolioId => {\n    const PortfolioData = await noneTokenClient.get(`${process.env.REACT_APP_API_URL}/portfolios/${portfolioId}`);\n    return PortfolioData.data;\n  }\n};\nexport const PortfolioCommentAPI = {\n  getPortfolioComment: async portfolioId => {\n    const commentData = await tokenClient.get(`${process.env.REACT_APP_API_URL}/api/portfoliocomments/portfolios/${portfolioId}`);\n    return commentData.data.data;\n  },\n  postPortfolioComment: async _ref => {\n    let {\n      userId,\n      portfolioId,\n      content\n    } = _ref;\n    return await tokenClient.post(`${process.env.REACT_APP_API_URL}/api/portfoliocomments`, {\n      userId,\n      portfolioId,\n      content\n    });\n  },\n  patchPortfolioComment: async _ref2 => {\n    let {\n      portfolioCommentId,\n      userId,\n      portfolioId,\n      content\n    } = _ref2;\n    return await tokenClient.patch(`${process.env.REACT_APP_API_URL}/api/portfoliocomments/${portfolioCommentId}`, {\n      portfolioCommentId,\n      userId,\n      portfolioId,\n      content\n    });\n  }\n};\nexport const UserCommentAPI = {};\nexport { tokenClient, noneTokenClient };","map":{"version":3,"names":["axios","useAppSelector","useAppDispatch","getNewAccessToken","setAccessToken","REFRESH_URL","noneTokenClient","create","baseURL","process","env","REACT_APP_API_URL","tokenClient","_s","interceptors","request","use","config","headers","url","Authorization","state","login","refreshToken","accessToken","_s2","response","error","originalRequest","status","_retry","dispatch","authorization","console","log","Promise","reject","errorResponse","data","userAPI","PortfolioAPI","getPortfolio","portfolioId","PortfolioData","get","PortfolioCommentAPI","getPortfolioComment","commentData","postPortfolioComment","_ref","userId","content","post","patchPortfolioComment","_ref2","portfolioCommentId","patch","UserCommentAPI"],"sources":["D:/Users/hoinlee/Desktop/HOIN/codestates/main-project/seb43_main_001/client/src/api/client.ts"],"sourcesContent":["// axios\r\nimport axios from 'axios';\r\n\r\n// redux\r\nimport { useAppSelector, useAppDispatch } from '../hooks/reduxHook';\r\n\r\n// util\r\nimport { getNewAccessToken } from '../utils/getAccessToken';\r\n\r\n// types\r\nimport {\r\n  GetPortfolioCommentById,\r\n  GetPortfolio,\r\n  PostPortfolioComment,\r\n  PatchPortfolioComment,\r\n} from '../types/index';\r\n\r\n// redux\r\nimport { setAccessToken } from '../store/slice/loginSlice';\r\n\r\n// ? 변수 선언 말고 바로 넣는 게 보안상 더 좋으려나?\r\n\r\nconst REFRESH_URL = ''; // refresh URL을 새롭게 추가를 해야 한다.\r\n\r\nconst noneTokenClient = axios.create({ baseURL: process.env.REACT_APP_API_URL });\r\nconst tokenClient = axios.create({ baseURL: process.env.REACT_APP_API_URL });\r\n\r\n// *: 요청하는 상태에 따라서 무조건 토큰을 담아서 보낸다.\r\ntokenClient.interceptors.request.use((config) => {\r\n  // * :요청 헤더가 있으면 기존의 것을 반환하고 없으면 아래 처럼 새롭게 지정해준다.\r\n  if (!config.headers) return config;\r\n\r\n  if (config.url === REFRESH_URL) {\r\n    config.headers.Authorization = `${useAppSelector((state) => state.login.refreshToken)}`;\r\n  } else {\r\n    config.headers.Authorization = `${useAppSelector((state) => state.login.accessToken)}`;\r\n  }\r\n\r\n  return config;\r\n});\r\n\r\n// *: token을 사용하는 response 설정\r\ntokenClient.interceptors.response.use(\r\n  (response) => {\r\n    return response;\r\n  },\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n\r\n    // originalRequest._retry은 재시도 여부를 나타낸다(계속 요청하는 loop를 방지하기 위해)\r\n    if (error.response.status === 401 && originalRequest && !originalRequest._retry) {\r\n      originalRequest._retry = true;\r\n\r\n      try {\r\n        // refreshToken을 이용해 새로운 accessToken 발급\r\n        const { accessToken } = await getNewAccessToken();\r\n\r\n        // 새롭게 발급 받은 accessToken을 로컬 스토리지에 저장하기\r\n        const dispatch = useAppDispatch();\r\n\r\n        dispatch(setAccessToken(accessToken));\r\n\r\n        // *:새롭게 받은 accessToken을 다시 기존의 요청 헤더 권한에 부여\r\n        originalRequest.headers.authorization = `${accessToken}`;\r\n\r\n        // 실패했던 원래 요청에 대해 다시 요청을 보낸다.\r\n        return await axios(originalRequest);\r\n      } catch (error) {\r\n        // refreshToken으로 accessToken 발급을 실패한 경우\r\n        console.log('Error in getNewAccessToken: ', error);\r\n        // 로그아웃 처리 등의 작업을 한다. 발급 실패를 했으니 어떻게 해야 하나?\r\n        // 에러 페이지로 전환을 해야 할까?\r\n      }\r\n    }\r\n    return Promise.reject(error);\r\n  },\r\n);\r\n\r\n// *: token을 사용하지 않는 response 설정\r\nnoneTokenClient.interceptors.response.use(\r\n  (response) => {\r\n    return response;\r\n  },\r\n  (error) => {\r\n    const errorResponse = {\r\n      ...error.response.data,\r\n    };\r\n\r\n    return Promise.reject(errorResponse);\r\n  },\r\n);\r\n\r\nexport const userAPI = {};\r\n\r\nexport const PortfolioAPI = {\r\n  getPortfolio: async (portfolioId: number): Promise<GetPortfolio> => {\r\n    const PortfolioData = await noneTokenClient.get(\r\n      `${process.env.REACT_APP_API_URL}/portfolios/${portfolioId}`,\r\n    );\r\n    return PortfolioData.data;\r\n  },\r\n};\r\n\r\nexport const PortfolioCommentAPI = {\r\n  getPortfolioComment: async (portfolioId: number): Promise<GetPortfolioCommentById[]> => {\r\n    const commentData = await tokenClient.get(\r\n      `${process.env.REACT_APP_API_URL}/api/portfoliocomments/portfolios/${portfolioId}`,\r\n    );\r\n    return commentData.data.data;\r\n  },\r\n  postPortfolioComment: async ({ userId, portfolioId, content }: PostPortfolioComment) => {\r\n    return await tokenClient.post(`${process.env.REACT_APP_API_URL}/api/portfoliocomments`, {\r\n      userId,\r\n      portfolioId,\r\n      content,\r\n    });\r\n  },\r\n  patchPortfolioComment: async ({\r\n    portfolioCommentId,\r\n    userId,\r\n    portfolioId,\r\n    content,\r\n  }: PatchPortfolioComment) => {\r\n    return await tokenClient.patch(\r\n      `${process.env.REACT_APP_API_URL}/api/portfoliocomments/${portfolioCommentId}`,\r\n      {\r\n        portfolioCommentId,\r\n        userId,\r\n        portfolioId,\r\n        content,\r\n      },\r\n    );\r\n  },\r\n};\r\n\r\nexport const UserCommentAPI = {};\r\n\r\nexport { tokenClient, noneTokenClient };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}