{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\n// axios\nimport axios from 'axios';\n\n// redux\nimport { useAppSelector, useAppDispatch } from '../hooks/reduxHook';\n\n// util\nimport { getNewAccessToken } from '../utils/getAccessToken';\n\n// types\n\n// redux\nimport { setAccessToken } from '../store/slice/loginSlice';\n\n// ? 변수 선언 말고 바로 넣는 게 보안상 더 좋으려나?\n\nconst REFRESH_URL = ''; // refresh URL을 새롭게 추가를 해야 한다.\n// ! nontoken은 제외\nconst noneTokenClient = axios.create({\n  baseURL: process.env.REACT_APP_API_URL\n});\nconst tokenClient = axios.create({\n  baseURL: process.env.REACT_APP_API_URL\n});\n\n// *: 요청하는 상태에 따라서 무조건 토큰을 담아서 보낸다.\n_s(tokenClient.interceptors.request.use(_s(config => {\n  _s();\n  // * :요청 헤더가 있으면 기존의 것을 반환하고 없으면 아래 처럼 새롭게 지정해준다.\n  // !login 상태가 아니면 그냥 일반 헤더 반환\n  // !login 상태면 아래와 같이 그냥 진행\n  if (!useAppSelector(state => state.login.isLogin)) {\n    return config;\n  }\n  if (!config.headers) {\n    return config;\n  }\n  // REFRESH_URL 기준으로 분류 처리를\n  if (config.url === REFRESH_URL) {\n    config.headers.Authorization = `${useAppSelector(state => state.login.refreshToken)}`;\n  } else {\n    config.headers.Authorization = `${useAppSelector(state => state.login.accessToken)}`;\n  }\n  return config;\n}, \"AAPi2IDUa7nqfRIl/B5P/Zb1mX4=\", false, function () {\n  return [useAppSelector, useAppSelector, useAppSelector];\n})), \"AAPi2IDUa7nqfRIl/B5P/Zb1mX4=\", false, function () {\n  return [useAppSelector, useAppSelector, useAppSelector];\n});\n\n// *: token을 사용하는 response 설정\n_s2(tokenClient.interceptors.response.use(response => {\n  return response;\n}, _s2(async error => {\n  _s2();\n  const originalRequest = error.config;\n  // !판단 기준은 state.login에 토큰이 있냐 없냐로 판별해라\n  // !로그인을 안 했을 때의 401은 그냥 reject(Promise)를 반환해라!\n\n  // Login 상태가 아닐 때는 그냥 error을 반환하는 형식\n  if (!useAppSelector(state => state.login.isLogin)) {\n    return Promise.reject(error);\n  }\n\n  // originalRequest._retry은 재시도 여부를 나타낸다(계속 요청하는 loop를 방지하기 위해)\n  if (error.response.status === 401 && originalRequest && !originalRequest._retry) {\n    originalRequest._retry = true;\n    try {\n      // refreshToken을 이용해 새로운 accessToken 발급\n      const {\n        accessToken\n      } = await getNewAccessToken();\n\n      // 새롭게 발급 받은 accessToken을 로컬 스토리지에 저장하기\n      const dispatch = useAppDispatch();\n      dispatch(setAccessToken(accessToken));\n\n      // *:새롭게 받은 accessToken을 다시 기존의 요청 헤더 권한에 부여\n      originalRequest.headers.authorization = `${accessToken}`;\n\n      // 실패했던 원래 요청에 대해 다시 요청을 보낸다.\n      return await axios(originalRequest);\n    } catch (error) {\n      // refreshToken으로 accessToken 발급을 실패한 경우\n      console.log('Error in getNewAccessToken: ', error);\n      // 로그아웃 처리 등의 작업을 한다. 발급 실패를 했으니 어떻게 해야 하나?\n      // 에러 페이지로 전환을 해야 할까?\n    }\n  }\n\n  return Promise.reject(error);\n}, \"Cc9Z7NzrH3jyIJwxisVWz1E3i3Q=\", false, function () {\n  return [useAppSelector, useAppDispatch];\n})), \"Cc9Z7NzrH3jyIJwxisVWz1E3i3Q=\", false, function () {\n  return [useAppSelector, useAppDispatch];\n});\n\n// *: token을 사용하지 않는 response 설정\nnoneTokenClient.interceptors.response.use(response => {\n  return response;\n}, error => {\n  const errorResponse = {\n    ...error.response.data\n  };\n  return Promise.reject(errorResponse);\n});\nexport const userAPI = {};\nexport const PortfolioAPI = {\n  getPortfolio: async portfolioId => {\n    const PortfolioData = await noneTokenClient.get(`${process.env.REACT_APP_API_URL}/portfolios/${portfolioId}`);\n    return PortfolioData.data;\n  }\n};\nexport const PortfolioCommentAPI = {\n  getPortfolioComment: async portfolioId => {\n    const commentData = await tokenClient.get(`${process.env.REACT_APP_API_URL}/api/portfoliocomments/portfolios/${portfolioId}`);\n    return commentData.data.data;\n  },\n  postPortfolioComment: async _ref => {\n    let {\n      userId,\n      portfolioId,\n      content\n    } = _ref;\n    return await tokenClient.post(`${process.env.REACT_APP_API_URL}/api/portfoliocomments`, {\n      userId,\n      portfolioId,\n      content\n    });\n  },\n  patchPortfolioComment: async _ref2 => {\n    let {\n      portfolioCommentId,\n      userId,\n      portfolioId,\n      content\n    } = _ref2;\n    return await tokenClient.patch(`${process.env.REACT_APP_API_URL}/api/portfoliocomments/${portfolioCommentId}`, {\n      portfolioCommentId,\n      userId,\n      portfolioId,\n      content\n    });\n  }\n};\nexport const UserCommentAPI = {};\nexport { tokenClient, noneTokenClient };","map":{"version":3,"names":["axios","useAppSelector","useAppDispatch","getNewAccessToken","setAccessToken","REFRESH_URL","noneTokenClient","create","baseURL","process","env","REACT_APP_API_URL","tokenClient","_s","interceptors","request","use","config","state","login","isLogin","headers","url","Authorization","refreshToken","accessToken","_s2","response","error","originalRequest","Promise","reject","status","_retry","dispatch","authorization","console","log","errorResponse","data","userAPI","PortfolioAPI","getPortfolio","portfolioId","PortfolioData","get","PortfolioCommentAPI","getPortfolioComment","commentData","postPortfolioComment","_ref","userId","content","post","patchPortfolioComment","_ref2","portfolioCommentId","patch","UserCommentAPI"],"sources":["D:/Users/hoinlee/Desktop/HOIN/codestates/main-project/seb43_main_001/client/src/api/client.ts"],"sourcesContent":["// axios\r\nimport axios from 'axios';\r\n\r\n// redux\r\nimport { useAppSelector, useAppDispatch } from '../hooks/reduxHook';\r\n\r\n// util\r\nimport { getNewAccessToken } from '../utils/getAccessToken';\r\n\r\n// types\r\nimport {\r\n  GetPortfolioCommentById,\r\n  GetPortfolio,\r\n  PostPortfolioComment,\r\n  PatchPortfolioComment,\r\n} from '../types/index';\r\n\r\n// redux\r\nimport { setAccessToken } from '../store/slice/loginSlice';\r\n\r\n// ? 변수 선언 말고 바로 넣는 게 보안상 더 좋으려나?\r\n\r\nconst REFRESH_URL = ''; // refresh URL을 새롭게 추가를 해야 한다.\r\n// ! nontoken은 제외\r\nconst noneTokenClient = axios.create({ baseURL: process.env.REACT_APP_API_URL });\r\nconst tokenClient = axios.create({ baseURL: process.env.REACT_APP_API_URL });\r\n\r\n// *: 요청하는 상태에 따라서 무조건 토큰을 담아서 보낸다.\r\ntokenClient.interceptors.request.use((config) => {\r\n  // * :요청 헤더가 있으면 기존의 것을 반환하고 없으면 아래 처럼 새롭게 지정해준다.\r\n  // !login 상태가 아니면 그냥 일반 헤더 반환\r\n  // !login 상태면 아래와 같이 그냥 진행\r\n  if (!useAppSelector((state) => state.login.isLogin)) {\r\n    return config;\r\n  }\r\n\r\n  if (!config.headers) {\r\n    return config;\r\n  }\r\n  // REFRESH_URL 기준으로 분류 처리를\r\n  if (config.url === REFRESH_URL) {\r\n    config.headers.Authorization = `${useAppSelector((state) => state.login.refreshToken)}`;\r\n  } else {\r\n    config.headers.Authorization = `${useAppSelector((state) => state.login.accessToken)}`;\r\n  }\r\n\r\n  return config;\r\n});\r\n\r\n// *: token을 사용하는 response 설정\r\ntokenClient.interceptors.response.use(\r\n  (response) => {\r\n    return response;\r\n  },\r\n  async (error) => {\r\n    const originalRequest = error.config;\r\n    // !판단 기준은 state.login에 토큰이 있냐 없냐로 판별해라\r\n    // !로그인을 안 했을 때의 401은 그냥 reject(Promise)를 반환해라!\r\n\r\n    // Login 상태가 아닐 때는 그냥 error을 반환하는 형식\r\n    if (!useAppSelector((state) => state.login.isLogin)) {\r\n      return Promise.reject(error);\r\n    }\r\n\r\n    // originalRequest._retry은 재시도 여부를 나타낸다(계속 요청하는 loop를 방지하기 위해)\r\n    if (error.response.status === 401 && originalRequest && !originalRequest._retry) {\r\n      originalRequest._retry = true;\r\n\r\n      try {\r\n        // refreshToken을 이용해 새로운 accessToken 발급\r\n        const { accessToken } = await getNewAccessToken();\r\n\r\n        // 새롭게 발급 받은 accessToken을 로컬 스토리지에 저장하기\r\n        const dispatch = useAppDispatch();\r\n\r\n        dispatch(setAccessToken(accessToken));\r\n\r\n        // *:새롭게 받은 accessToken을 다시 기존의 요청 헤더 권한에 부여\r\n        originalRequest.headers.authorization = `${accessToken}`;\r\n\r\n        // 실패했던 원래 요청에 대해 다시 요청을 보낸다.\r\n        return await axios(originalRequest);\r\n      } catch (error) {\r\n        // refreshToken으로 accessToken 발급을 실패한 경우\r\n        console.log('Error in getNewAccessToken: ', error);\r\n        // 로그아웃 처리 등의 작업을 한다. 발급 실패를 했으니 어떻게 해야 하나?\r\n        // 에러 페이지로 전환을 해야 할까?\r\n      }\r\n    }\r\n    return Promise.reject(error);\r\n  },\r\n);\r\n\r\n// *: token을 사용하지 않는 response 설정\r\nnoneTokenClient.interceptors.response.use(\r\n  (response) => {\r\n    return response;\r\n  },\r\n  (error) => {\r\n    const errorResponse = {\r\n      ...error.response.data,\r\n    };\r\n\r\n    return Promise.reject(errorResponse);\r\n  },\r\n);\r\n\r\nexport const userAPI = {};\r\n\r\nexport const PortfolioAPI = {\r\n  getPortfolio: async (portfolioId: number): Promise<GetPortfolio> => {\r\n    const PortfolioData = await noneTokenClient.get(\r\n      `${process.env.REACT_APP_API_URL}/portfolios/${portfolioId}`,\r\n    );\r\n    return PortfolioData.data;\r\n  },\r\n};\r\n\r\nexport const PortfolioCommentAPI = {\r\n  getPortfolioComment: async (portfolioId: number): Promise<GetPortfolioCommentById[]> => {\r\n    const commentData = await tokenClient.get(\r\n      `${process.env.REACT_APP_API_URL}/api/portfoliocomments/portfolios/${portfolioId}`,\r\n    );\r\n    return commentData.data.data;\r\n  },\r\n  postPortfolioComment: async ({ userId, portfolioId, content }: PostPortfolioComment) => {\r\n    return await tokenClient.post(`${process.env.REACT_APP_API_URL}/api/portfoliocomments`, {\r\n      userId,\r\n      portfolioId,\r\n      content,\r\n    });\r\n  },\r\n  patchPortfolioComment: async ({\r\n    portfolioCommentId,\r\n    userId,\r\n    portfolioId,\r\n    content,\r\n  }: PatchPortfolioComment) => {\r\n    return await tokenClient.patch(\r\n      `${process.env.REACT_APP_API_URL}/api/portfoliocomments/${portfolioCommentId}`,\r\n      {\r\n        portfolioCommentId,\r\n        userId,\r\n        portfolioId,\r\n        content,\r\n      },\r\n    );\r\n  },\r\n};\r\n\r\nexport const UserCommentAPI = {};\r\n\r\nexport { tokenClient, noneTokenClient };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}